- Intro slide
- Hello, World Example
    - Explain:
        - `fn` declaration
        - `println` is a macro
    - Format strings in `println!`
        - `println("Hello, {}!", world);`
        - also show `{:?}`
    - Move "world" into a local variable so we can change it
        - `let name = "Rustacean"; println("Hello, {}!", name);`
    - Abstract into a helper fn
        - `fn greet(name: String) { println("Hello, {}!", name); }`
        - What goes wrong?
            - Explain `format!`, show how you can use same helpers
            - Explain `push_str` and mutable local variables
                - `let mut name = format!("fellow "); name.push_str("Rustacean");`
    - Call helper fn twice
        - What goes wrong now?
- Ownership slides
- Borrowing slides
- Borrowing example
    - Show that `&` and `&mut` cannot overlap
    - Time-limited
- For loops
  - show that `s` has type `String`
- Options and enums
  - explain about `unwrap` and how it is risky
  - show `let x = None` and unwrap
  - modify to some other example, like Shape / Square / Circle
- Sequential search
  - 10 minutes, wonder about
- Parallel search
  - note the `use` statement
  - let's look at these two curious clones:
    - we'll start with `shopping_list`
      - type of `shopping_list` is in fact a reference
      - threads can't close over a reference
        - try to remove the clone, see what happens
    - what about `name`?
      - `name` is needed because `store` is moved into
  - how do we parallelize?
    - we have to start ALL the threads before we join ANY of them
- 
- Shared memory exercise
  - Afterwards:
    - show how you can change so that we request an
      `Vec<ShoppingList>` instead of `&Vec`, note that in general if
      you will consume data, it's best to take it by value, and let
      the owner clone if they must
    - note that this applies equally well when using channels,
      and in fact a common pattern is to send an `Arc<T>` over a channel
-       
